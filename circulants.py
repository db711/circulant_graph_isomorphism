#    Written by Daniel Berger (daniel.berger@stud-mail.uni-wuerzburg.de)
#    at the Julius Maximilian University of Würzburg
#    as part of my bachelor thesis with the title
#    "Das Isomorphieproblem für zirkuläre Graphen",
#    written at the Institute of Mathematics in 2019.
#    Based on the the paper 
#	 "A solution of the isomorphism problem for circulant graphs"
#	 by M. Muzychuk. See https://doi.org/10.1112/S0024611503014412

#import matplotlib as mpl
#import matplotlib.pyplot as plt
#import networkx as nx
#import scipy
from sympy import factorint
import itertools
import math

#def circulant_digraph(n, connection_set):
#    """
#    Generates a directed circulant graph of order n 
#    with connection set connection_set.
#    Based on networkx's DiGraph class.
#    """
#    G = nx.DiGraph()
#    for x in range(n):
#        for s in connection_set:
#            G.add_edge(x, (x + s)%n)
#    return G

def generate_primary_keys(a):
    """
    Generates all primary keys in the primary key space K_{p^a} as tuples
    and returns them in a list. Works recursively.
    """
    if(a == 1): # Base case
        return [(0,)]
    elif(a > 1):
        key_space = []
        # For all keys in the key space K_{p^a}
        for key in generate_primary_keys(a-1):
            for i in reversed(range(a)): # Go backwards to potentially break early
                # Check if appending i generates a valid key
                if key[-1] <= i:
                    # If yes, do it and append to key_space
                    key2 = list(key)
                    key2.append(i)
                    key_space.append(tuple(key2))
                else: # If i can't be appended, neither can all lower numbers
                    break
        return key_space

def compute_keyspace(n):
    """
    Computes the key space K_n as a cartesian product of
    primary key spaces generated by generate_primary_keys
    and returns it as a list.
    """
    factorization = factorint(n) # Factorizes n
    primary_spaces = [] # List to store primary key spaces
    for p in factorization.keys(): # For every prime p in the factorization of n
        a = factorization.get(p) # Get the exponent a of p
        # Generate the corresponding primary key space and add it to our list
        primary_spaces.append(generate_primary_keys(a))
    key_space = []
    # Compute the cartesian product
    for element in itertools.product(*primary_spaces):
        key_space.append(element)
    return key_space

def primary_genuine_generalized_multiplier_key(k, p):
    """
    Generates all genuine generalized multipliers related to the primary key k as tuples
    and returns them in a list.
    Requires the corresponding prime number p as input.
    Returns Z_{p^a}^{**}(k)^o as a list. Works recursively.
    """
    multipliers = []
    if len(k) == 1: # Base case
        # In this case all coprime to p elements in {1,...,p-1} are valid multipliers
        for i in range(1, p):
            multipliers.append((i,))
    else:
        # Look at all multipliers m for the key that is 1 element shorter
        for m in primary_genuine_generalized_multiplier_key(k[:-1], p):
            for m_d in range( 1, p**(len(k) - k[-1]) ): # See (M2_p)
                if ( (math.gcd(m_d,p) == 1) and # See (M1_p)
                    (m_d%(p**(len(k) - k[-1] - 1)) == m[-1]%(p**(len(k) - k[-1] - 1))) ):
                    m2 = list(m)
                    m2.append(m_d)
                    multipliers.append(tuple(m2))
    return(multipliers)

def genuine_generalized_multiplier_key(k, n):
    """
    Generates all genuine generalized multipliers 
    related to the the composite key k in K_n.
    Won't work if the number of prime factors in n is not len(k).
    Returns Z_n^{**}(k)^o. Uses genuine_generalized_multiplier_key.
    """
    factorization = factorint(n) # Factorizes n
    primary_multipliers = [] # List to store multipliers related to prime p
    i = 0 # Used for counting
    # For every prime p in the factorization of n, 
    # compute the genuine generalized multiplier and store it in our list
    for p in factorization:
        primary_multipliers.append( primary_genuine_generalized_multiplier_key(k[i], p))
        i += 1
    multipliers = []
    # Compute the cartesian product
    for element in itertools.product(*primary_multipliers):
        multipliers.append(element)
    return multipliers

       
def compute_union_ggm(n): # DEPRECATED
    """
    Computes the union of all genuine generalized multipliers in the keyspace K_n
    Returns the result as a set. 
    Uses composite_genuine_generalized_multiplier and compute_keyspace.
    """
    P = set()
    for i in compute_keyspace(n):
        P = P.union(set(genuine_generalized_multiplier_key(i, n)))
    return P

def p_adic(x, p, a):
    """
    Computes the p-adic representation of x in Z_{p^a}.
    Requires p to be prime and a > 0.
    Returns the result in a dict; for example:
    p_adic(5, 2, 3) = {4: 1, 2: 0, 1: 1}.
    ( the 2-adic representation of 5 in Z_8 is 101,
    because 1*(2**2) + 0*(2**1) + 1*(2**0) = 5 )
    """
    p_dict = {}
    for i in reversed(range(a)): # Start with largest power of p
        j = 0 # Counts how often x is divisible by p**i
        while x >= p**i:
            j += 1
            x -= p**i
        p_dict[p**i] = j
    return p_dict

def primary_permute(m, x, p, a):
    """
    Compute the image of x under f_m for a generalized multiplier m in Z_{p^a}.
    Requires p to be prime and a > 0. Uses p_adic.
    """
    p_dict = p_adic(x, p, a)
    fx = 0 # Image of x under f_m
    j = 0 # Used for counting
    for m_i in reversed(m):
        fx += m_i * p_dict[p**j] * (p**j)
        j += 1
    return fx%(p**a)

def permute(m, x, n):
    """
    Compute the image of x under f_m for a generalized multiplier m in Z_n.
    Uses primary_permute.
    """
    factorization = factorint(n) # Factorizes n
    # Compute Z_n as direct sum Z_{p_1^{a_1}} x ... x Z_{p_l^{a_l}}
    direct_sum = [] 
    i = 0 # Used for counting
    #For every prime p in the factorization of n
    for p in factorization.keys():
        # f_{m_i} is applied to the i'th "coordinate" of the direct sum
        # See also Chinese Remainder Theorem
        direct_sum.append(
                primary_permute(m[i],x%(p**factorization[p]), p ,factorization[p])) 
        i+=1
    # Compute preimage of the result under the CRT isomorphism
    # TODO: Could possibly be slightly improved
    for x in range(n): 
        test = []
        for p in factorization.keys():
            test.append(x%(p**factorization[p]))
        if test == direct_sum:
            return x   
    
def primary_key_partition(k, p):
    """
    Compute the key partition for a primary key k in Z_{p^a},
    where a = len(k). Result is a partition of Z_{p^a}
    Returns the partition as a set and its elements as frozensets.
    """
    a = len(k)
    partition = {frozenset((0,))}
    for g in range(1,p**a): # For every g in Z_{p^a}
        # Find b such that ord(g) = p^b
        b = 1 
        while g*(p**b)%(p**a) != 0:
            b+=1
        element = p**(a - k[b-1]) 
        # We compute the subgroup generated by element
        generated  = [0]
        c = 1 # Used for counting
        while (c*element)%(p**a) != 0:
            generated.append(c*element)
            c+=1
        # The elements of the partition (cells) are cosets of this subgroup
        cell = frozenset([(x+g)%(p**a) for x in generated])
        partition.add(cell)
    return partition

def key_partition(k, n):
    """
    Generate key partition for a composite key k in Z_n.
    Result is a partition of Z_n.
    Returns the partitions as a list, whose elements are sets.
    Uses primary_key_partition.
    """
    factorization = factorint(n) # Factorizes n
    # Create a lookup_dict to compute pre-images fast
    lookup_dict = {}
    for x in range(n):
        factor = []
        for p in factorization.keys():
            factor.append(x%(p**factorization[p]))
        lookup_dict[tuple(factor)] = x
    #print(lookup_dict)
        
    partition = [] # This will be our final partition
    primary_partitions = [] # List for primary partitions
    i = 0 # Used for counting
    for p in factorization.keys(): # For every prime p in the factorization of n
        # Append the corresponding primary key partition to our list
        primary_partitions.append(list(primary_key_partition(k[i], p)))
        i+=1
    # Compute the cartesian product of that
    product1 = []
    for element in itertools.product(*primary_partitions):
        product1.append(element)
    # Look at every element in that product
    for factor in product1:
        product2 = [] # This will be an element Z_{p_1^{a_1}} x ... x Z_{p_l^{a_l}}
        for element in itertools.product(*factor): # Cartesian product
            product2.append(element)
        cell = set() # This will be an element of our final partition
        for i in product2:
            cell.add(lookup_dict[i])                 
        partition.append(cell)
    return partition

def is_finer_partition(partition1, partition2):
    """
    Check whether a partition is finer than the other.
    Returns True if partition1 is finer than partition2, False otherwise.
    """
    for s1 in partition1:
        check = False
        for s2 in partition2:
            if s1.issubset(s2):
                check = True
                break
        if not check:
            return False
    return True
    
def key_of_partition(partition):
    """
    Compute and return the key of a partition.
    """
    # Get cardinality of the set that partition is a partition of
    n = 0
    for part in partition:
        n += len(part)
    # Create dict for all finer partitions
    finer_partitions = {}
    for key in compute_keyspace(n): # For every key in the key space K_n
        # Partition corresponding to k = key
        partition_k = key_partition(key, n)
        if is_finer_partition(partition_k, partition): # Check if it's finer
            finer_partitions[key] = partition_k
    for key in finer_partitions.keys(): # For all finer keys
        # We check if the corresponding partition is the coarsest
        counter = 0
        for part2 in finer_partitions.values():
            if is_finer_partition(finer_partitions[key], part2):
                counter += 1
                if counter > 1:
                    break
        if counter == 1: # We found the coarsest (only itself is finer)
            return key        
     
def list_isomorphic_graphs(n, connection_set):
    """
    List all the graphs that are isomorphic to the circulant graph of
    order n with connection set connection_set
    """
    Z_n = set(range(n))
    permutation_list = []
    key = key_of_partition([connection_set, Z_n.difference(connection_set)])
    for m in genuine_generalized_multiplier_key(key, n):
            permutation = set()
            for x in connection_set:
                permutation.add(permute(m, x, n))
            permutation_list.append(permutation)
    return permutation_list

def is_isomorphic(n, connection_set1, connection_set2):
    """
    Test if the two circulant graphs of order n
    corresponding to connection_set1 and connection_set2 respectively
    are isomorphic. Returns True if they are isomorphic, False otherwise.
    """
    Z_n = set(range(n))
    key1 = key_of_partition([connection_set1, Z_n.difference(connection_set1)])
    key2 = key_of_partition([connection_set2, Z_n.difference(connection_set2)])
    if key1 != key2: 
        return False
    for m in genuine_generalized_multiplier_key(key1, n):
        permutation = set()
        for x in connection_set1:
            permutation.add(permute(m, x, n))
        if permutation == connection_set2:
            return True
    return False

def colored_is_isomorphic(n, oPartition1, oPartition2):
    """
    Test if two colored circulant graphs of order n
    corresponding to the ordered partitions oPartition1 and oPartition2
    respectively are isomorphic.
    Return True if they are isomorphic, False otherwise.
    """
    for i in range(len(oPartition1)):
        if not is_isomorphic(n, oPartition1[i], oPartition2[i]):
            return False
    return True